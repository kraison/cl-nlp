(in-package #:nlp)

(defun make-pcfg-from-cfg (file &optional pos-db)
  (let ((rules (make-hash-table))
        (s-count (make-hash-table))
        (probabilities (make-hash-table))
        (index (make-hash-table)))
    (add-rule :start '(S) rules)
    (init-or-increment s-count :start)
    (with-open-file (in file)
      (do ((line (read-line in nil nil) (read-line in nil nil)))
          ((null line))
        (when (> (length line) 1)
          (destructuring-bind (lhs rhs) (split "\\s*->\\s*" line)
            (let ((lhs (intern lhs))
                  (rhs (mapcar #'intern (split "\\s+" rhs))))
              (init-or-increment s-count lhs)
              (add-rule lhs rhs rules))))))
    (maphash #'(lambda (lhs rhs)
                 (unless (hash-table-p (gethash lhs probabilities))
                   (setf (gethash lhs probabilities) (make-hash-table :test 'equalp)))
                 (dolist (rhs rhs)
                   (setf (gethash rhs (gethash lhs probabilities))
                         (/ 1 (gethash lhs s-count))))
                 (if (listp rhs)
                     (dolist (p rhs)
                       (if (listp p)
                           (add-rule (first p) lhs index)
                           (add-rule p lhs index)))
                     (add-rule rhs lhs index)))
             rules)
    (if (pos-db? pos-db)
        (values (setf (pos-cfg pos-db) rules)
                (setf (pos-cfg-idx pos-db) index)
                (setf (pos-pcfg pos-db) probabilities))
        (values rules index probabilities))))
