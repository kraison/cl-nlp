(in-package #:nlp)

(defvar +eos+ #\Nul)
(defparameter *ellipsis* "([.]+)")
(defparameter *post-punctuation* "[.!?](\\?|:|'|\\\"|\\)|\\]|\\})?")

(defparameter *people*
  '("jr" "mr" "mrs" "ms" "dr" "prof" "sr" "sens?" "reps?" "gov" "attys?"
    "supt"  "det" "rev"))
(defparameter *army*
  '("col" "gen" "lt" "cmdr" "adm" "capt" "sgt" "cpl" "maj"))
(defparameter *institutes* '("dept" "univ" "assn" "bros"))
(defparameter *company* '("inc" "ltd" "co" "corp" "llp" "llc"))
(defparameter *places*
  '("arc" "al" "ave" "blv?d" "cl" "ct" "cres" "dr" "expy?"
    "dist" "mt" "ft"
    "fw?y" "hwa?y" "la" "pde?" "pl" "plz" "rd" "st" "tce"))
(defparameter *states*
  '("Ala" "Ariz" "Ark" "Cal" "Calif" "Col" "Colo" "Conn"
    "Del" "Fed" "Fla" "Ga" "Ida" "Id" "Ill" "Ind" "Ia"
    "Kan" "Kans" "Ken" "Ky" "La" "Me" "Md" "Is" "Mass"
    "Mich" "Minn" "Miss" "Mo" "Mont" "Neb" "Nebr" "Nev"
    "Mex" "Okla" "Ok" "Ore" "Penna" "Penn" "Pa" "Dak"
    "Tenn" "Tex" "Ut" "Vt" "Va" "Wash" "Wis" "Wisc" "Wy"
    "Wyo" "USAFA" "Alta" "Man" "Ont" "Qué" "Sask" "Yuk"))
(defparameter *months*
  '("jan" "feb" "mar" "apr" "may" "jun" "jul" "aug" "sep" "oct" "nov" "dec"
    "sept"))
(defparameter *misc* '("vs" "etc" "no" "esp"))

(let ((nl-scanner (create-scanner (format nil "\\n\s*\\n")))
      (el-scanner (create-scanner (format nil "\\w~A" *ellipsis*)))
      (pp-scanner (create-scanner (format nil "(~A)(\\s+|$)"
                                          *post-punctuation*)))
      (p-scanner (create-scanner (format nil "\\s\\w~A" *punctuation*))))
  (defun mark-sentence-boundaries (text)
    "Make a first pass at marking sentence boundaries"
    (let ((new-text nil))
      (setq new-text
            (regex-replace-all nl-scanner text (format nil "~A" +eos+)))
      (setq new-text
            (regex-replace-all el-scanner new-text (format nil "\\\&~A" +eos+)))
      (setq new-text
            (regex-replace-all pp-scanner
                               new-text
                               (format nil "\\\1~A" +eos+)))
      (setq new-text
            (regex-replace-all p-scanner
                               new-text
                               (format  nil "\\\&~A" +eos+)))
      (setq new-text
            (regex-replace-all (format nil "[~A]{2,}" +eos+)
                               new-text
                               (format nil "~A" +eos+)))
      new-text)))

(let ((host-scanner
       (let ((*allow-named-registers* t))
         (create-scanner
          (format nil "([a-z\\d]([a-z\\d\\-]{0,61}[a-z\\d])?(\\.([~A])?[a-z\\d]([a-z\\d\\-]{0,61}[a-z\\d])?)+)" +eos+)
          :multi-line-mode t
          :case-insensitive-mode t))))
  (defun normalize-host-and-ip (text)
    (do-register-groups (a) (host-scanner text)
      (setq text (regex-replace a text (regex-replace-all (format nil "[~A]" +eos+) a ""))))
    text))

(let ((abbr-scanner-nocase
       (create-scanner
        (with-output-to-string (regex)
          (format regex "([^\\\w])")
          (format regex "(~{~A~^|~}"
                  (append *people* *months* *misc* *company* *army*
                          *institutes* *places*))
          (format regex ")~A~A" *punctuation* +eos+))
        :multi-line-mode t
        :case-insensitive-mode t))
      (abbr-scanner-case
       (create-scanner
        (format nil "(~{~A~^|~})~A~A" *states* *punctuation* +eos+)
        :case-insensitive-mode nil
        :multi-line-mode t)))
  (defun remove-false-boundaries (text)
    "Correct any bad boundaries that were generated by mark-sentence-boundaries"
    (setq text (normalize-host-and-ip text))
    (setq text
          (regex-replace-all
           (format nil "([^-\\w]\\w~A\\s)~A" *post-punctuation* +eos+) text "\\1"))
;    (setq text
;          (regex-replace-all
;           (format nil "([^-\\w]\\w~A)~A" *punctuation* +eos+) text "\\1"))
    (setq text
          (regex-replace-all (format nil "(\\s\\w\.\\s+)~A" +eos+) text "\\1"))
    (setq text
          (regex-replace-all (format nil "(\.\.\. )~A([a-z])" +eos+) text "\\1\\2"))
    (setq text
          (regex-replace-all (format nil "(['\\\"]~A['\\\"]\\s+)~A" *punctuation* +eos+)
                             text "\\1 "))
    (setq text
          (regex-replace-all (format nil "([\\\"']\\s*)~A(\\s*[a-z])" +eos+)
                             text "\\1 \\2"))
    (setq text (regex-replace-all (format nil "(\\s\.\\s)~A(\\s*)" +eos+)
                                  text "\\1\\2"))
    (setq text (regex-replace-all (format nil "(\\s~A\\s)~A"
                                          *post-punctuation* +eos+)
                                  text "\\1"))
    (setq text (regex-replace-all abbr-scanner-nocase text "\\1\\2\\3 "))
    (setq text (regex-replace-all abbr-scanner-case text "\\1\\2 "))
    (setq text (regex-replace-all (format nil "([0-9]+)(\\.)~A([0-9]+)" +eos+)
                                  text "\\1\\2\\3"))
    text))

(let ((eos-scanner (create-scanner (format nil "~A" +eos+))))
  (defmethod split-sentences ((language language) text)
    "Split text into sentences"
    (declare (ignore language))
    (mapcar (lambda (s)
              (regex-replace-all "(^\\s+|\\s+$)" s ""))
            (split eos-scanner
                   (remove-false-boundaries
                    (mark-sentence-boundaries text))))))

#+sbcl
(defun experimental-split-sentences (text &optional (language *language*))
  (declare (ignore language))
  (mapcar (lambda (sentence)
            (string-trim '(#\Space #\Tab #\Newline #\Return) sentence))
          (sb-unicode:sentences text)))

(defun split-contractions (word &optional (language *language*))
  (gethash word (contraction-table language)))

(defun handle-slashes (word)
  "Split non-numeric strings that have slashes in sub-strings."
  (if (> (length word) 1)
      (handler-case
          (progn
            (parse-number:parse-number word)
            word)
        (parse-number:invalid-number (c)
          (declare (ignore c))
          ;; it isn't a number format that we recognize, split up the substrings
          (cl-ppcre:split "(\/)" word :with-registers-p t))
        (error (c)
          (declare (ignore c))
          ;; We can get here if the numbers contain commas;  parse-number should
          ;; do a better job handling those.  For now, just return the string as-is
          word))
      word))

(defmethod tokenize ((language language) text)
  "Split text into tokens."
  (let ((text (cl-ppcre:regex-replace "(’|´)" (cl-ppcre:regex-replace "\\s+$" text "") "'"))
        (final-quote nil))
    (setq text (regex-replace-all "([\\.]+)$" text " \\1 "))
    (setq text (regex-replace-all "([\\.\\?\\!])([\\.]+)$" text " \\1 \\2 "))
    (setq text (regex-replace-all "([\\.\\?\\!])([\'\"])$" text " \\1 \\2 "))
    (setq text (regex-replace-all "(,)(['\\\"])" text "\\1 \\2"))
    (setq text (regex-replace-all "((^| )')([^']+)('( |$))" text " `` \\3 '' "))
    (setq text (regex-replace-all "(\")([^\"]+)(\")" text "`` \\2 '' "))
    (setq text (regex-replace-all "([^,])(,)" text "\\1 \\2 "))
    (setq text (regex-replace-all "([^;\\s])(;)" text "\\1 \\2 "))
    (setq text (regex-replace-all "([^:\\s(http)(https)(ftp)])(:)" text "\\1 \\2"))
    (setq text (regex-replace-all "(^| )(\\w+)(')( |$)" text "\\1\\2 \\3\\4"))
    (setq text (regex-replace-all "(\\()" text "\\1 "))
    (setq text (regex-replace-all "(\\))" text " \\1 "))
    (when (scan "[\\.\\?\\!] ''$" text)
      (setq final-quote t)
      (setq text (regex-replace-all " ''$" text "")))
    (let ((punctuation
           (cl-ppcre:scan-to-strings "[\\.\\?\\!]$" text)))
      (when punctuation
        (setq text (subseq text 0 (1- (length text)))))
      (let ((tokens
             (flatten
              (mapcar (lambda (word)
                        (cond ((cl-ppcre:scan "\\'s$" word)
                               (list (cl-ppcre:regex-replace "\\'s$" word "")
                                     "'s"))
                              ((cl-ppcre:scan "\\'d$" word)
                               (list (cl-ppcre:regex-replace "\\'d$" word "")
                                     "'d"))
                              ((cl-ppcre:scan "\/" word)
                               (handle-slashes word))
                              (t
                               (or (split-contractions word language) (list word)))))
                      (append (cl-ppcre:split "\\s+" text)
                              (when punctuation (list punctuation))
                              (when final-quote (list "''")))))))
        tokens))))

#+sbcl
(defmethod experimental-tokenize ((language language) text)
  "Split text into tokens."
  (flatten
   (mapcar (lambda (word)
             (or (split-contractions word language)
                 word))
           (delete " "
                   (sb-unicode:words text)
                   :test 'string-equal))))
